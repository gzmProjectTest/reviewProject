<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 影响原数组： 增（unshift/push）删（shifit/pop）改（splice）排（sort） 转（reverse）
        // 不影响原始数组： 拼（concat）复（splice/slice/） 截（slice）

    // 影响原数组
    // 增   返回值，新增数组后的 length
    /*
    let arr = [1, 2, 3];
    console.log(arr);
    console.log(arr.push(4)); // 后增
    console.log(arr);
    console.log(arr.unshift(0)); // 前增
    console.log(arr);
    */

    // 删   返回删除后的  元素
    /*
    let arr = [1, 2, 3];
    console.log(arr);
    console.log(arr.pop()); // 后删
    console.log(arr);
    console.log(arr.shift()); // 前删
    console.log(arr);
    */

    // 改 splice  返回截取后的  元素
    /*
    let arr = [1, 2, 3];
    console.log(arr);
    console.log(arr.splice(0, 1)); // 修改
    console.log(arr);
    console.log(arr.splice(0, 1,999)); // 修改
    console.log(arr);
    */

     // 复 copy concat slice  返回 拼接后的 新数组
    /*
    let arr = [1, 2, 3];
    let arr1 = arr;
    console.log(arr);
    console.log(arr1.push(4));
    console.log(arr);
    console.log(arr1);

    let arr = [1, 2, 3];
    let arr1 = arr.concat();
    console.log(arr);
    console.log(arr.push(4));
    console.log(arr);
    console.log(arr1);
    */

    // 排 reverse sort 返回排序后的数组  影响原数组 返回一个数组
    /*
    let arr = [1, 3, 2];
    console.log(arr);
    console.log(arr.reverse()); // 修改
    console.log(arr);
    
    let arr = [1, 3, 2];
    console.log(arr);
    console.log(arr.sort(function(a, b){return a - b})); // 修改
    console.log(arr);

    */

        
    


 
    /*

    var a = [1, 2, 3];

    console.log(a); // [1,2,3] 原数组
    console.log([].shift.call(a)); // 1  截取数组中的首位，并返回
    console.log(a); // [2,3] // 影响原数组，返回截取后的数组
    console.log([].shift.call(a)); // 2

    // 排序 sort
    var numbers = [4, 2, 5, 1, 3];
    var n1 = numbers;
    var n2 = numbers;
    n1.sort(function (a, b) {
        return a - b;
    });
    console.log(numbers, n1, n2); // 结果都是[1,2,3,4,5]

   */
    // 截取    不影响原数组  返回截取的新数组
    /*
    let arr = [1, 2, 3];
    console.log(arr);
    console.log(arr.slice(0, 1)); // 截取
    console.log(arr);
    */

     // 拼接 concat  返回 拼接后的 新数组
    /*
    let arr = [1, 2, 3];
    let arr1 = [4, 5, 6];
    console.log(arr);
    console.log(arr1);
    console.log(arr.concat(arr1)); // 拼接
    console.log(arr);
    console.log(arr1);
    */

    // 转 toString 将数组转化为 字符串， 不改变原数组
    /*
    let arr = [1, 3, 2];
    console.log(arr);
    console.log(arr.toString(',')); // 修改
    console.log(arr);
    */
 


    // 数组中的坑
    /*
    任意两个数组相等都会返回false；[]=[];//false
    怎么办？千万不要逐项去比较，看看上面可用的方法：toString();
    转化为字符串一次就比较完了。
    */
    </script>
    <script>
        // es5 新增数组方法  不改变原数组
    // new Set去重
    /*
    let arr = [1, 2, 2, 3, 3, 4];
    console.log(new Set(arr));
    */
    
    // 获取数组中的交集
    /*
    let arr = [1, 2, 2, 3, 3, 4];
    let arr1 = [2, 4];
    arr.filter((item, index) => {
        arr1.includes(item);
    });
    console.log(arr);
    console.log(arr1);
    */
   /*
   filter
    let arr = [1, 2, 2, 3, 3, 4];
    let arr1 = [];
    let arr2 = [];
    arr.filter((item, index) => {
        if (arr1.indexOf(item) >= -1){
            arr1.push(item);
        } else {
            arr2.push(item);
        };
    });
    console.log(arr1);
    console.log(arr2);
    */
    // some  检测数组中有一项不满足
    let arr = [1, 2, 2, 3, 3, 4];
    let arr1 = [];
    let arr2 = [];
    arr.some((item, index) => {
        if (item === 2) {
            arr1.push(item);
        }
    });
    console.log(arr1);
    console.log(arr2);
    </script>
</body>
</html>